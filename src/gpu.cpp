
////////////////////////////////////////////
// Generated by BRCC v0.1
// BRCC Compiled on: Nov 20 2006 11:39:32
////////////////////////////////////////////

#include <brook/brook.hpp>
static const char *__gpuGDAMatrix_ps20= NULL;
static const char *__gpuGDAMatrix_ps2b= NULL;
static const char *__gpuGDAMatrix_ps2a= NULL;
static const char *__gpuGDAMatrix_ps30= NULL;
static const char *__gpuGDAMatrix_fp30= NULL;
static const char *__gpuGDAMatrix_fp40= NULL;

namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __gpuGDAMatrix_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"# cgc version 1.4.0001, build date Mar  9 2006 20:56:09\n"
				"# command line args: -quiet -DCGC=1 -profile arbfp1 -DUSERECT=1 -profileopts MaxTexIndirections=4,NoDepenentReadLimit=0,NumInstructionSlots=96\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile arbfp1\n"
				"#program main\n"
				"#semantic main._tex_index : TEXUNIT0\n"
				"#semantic main.E : TEXUNIT1\n"
				"#semantic main.__gatherconst_E : C0\n"
				"#semantic main.pi : TEXUNIT2\n"
				"#semantic main.__gatherconst_pi : C1\n"
				"#semantic main.T : C2\n"
				"#semantic main.__workspace : C3\n"
				"#var samplerRECT _tex_index : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float2 _tex_index_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var samplerRECT E[0]TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float4 __gatherconst_E : C0 : c[0] : 3 : 1\n"
				"#var samplerRECT pi[0]TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float4 __gatherconst_pi : C1 : c[1] : 5 : 1\n"
				"#var float T : C2 : c[2] : 6 : 1\n"
				"#var float __output_0 : $vout.COLOR0 : COL : 7 : 1\n"
				"#var float4 __workspace : C3 : c[3] : 8 : 0\n"
				"#const c[4] = 0 2.718282 1 32\n"
				"PARAM c[5] = { program.local[0..3],\n"
				"		{ 0, 2.7182817, 1, 32 } };\n"
				"TEMP R0;\n"
				"TEMP R1;\n"
				"TEMP R2;\n"
				"TEX R2.xy, fragment.texcoord[0], texture[0], RECT;\n"
				"MOV R0.y, c[4].x;\n"
				"ADD R0.x, R2, c[0].z;\n"
				"TEX R0.x, R0, texture[1], RECT;\n"
				"MOV R0.w, c[4].x;\n"
				"ADD R0.z, R2.y, c[0];\n"
				"TEX R1.x, R0.zwzw, texture[1], RECT;\n"
				"ADD R0.x, R0, -R1;\n"
				"RCP R0.y, c[2].x;\n"
				"MUL R0.x, R0, R0.y;\n"
				"POW R0.x, c[4].y, R0.x;\n"
				"ADD R0.x, R0, c[4].z;\n"
				"MUL R0.x, R0, c[4].w;\n"
				"RCP R0.y, R0.x;\n"
				"MOV R0.w, c[4].x;\n"
				"ADD R0.z, R2.y, c[1];\n"
				"TEX R0.x, R0.zwzw, texture[2], RECT;\n"
				"MOV R0.w, c[4].x;\n"
				"ADD R0.z, R2.x, c[1];\n"
				"TEX R1.x, R0.zwzw, texture[2], RECT;\n"
				"ADD R0.x, R1, R0;\n"
				"MUL result.color.x, R0, R0.y;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:5\n"
				"##s:2:index\n"
				"##c:1:E\n"
				"##c:1:pi\n"
				"##c:1:T\n"
				"##o:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(2, kGatherConstant_Shape)
				.constant(3, kGatherConstant_Shape)
				.constant(4, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.output(5, 0)
			)
		);
	static const void* __gpuGDAMatrix_arb = &__gpuGDAMatrix_arb_desc;
}

void  __gpuGDAMatrix_cpu_inner(const __BrtFloat2  &index,
                              const __BrtArray<__BrtFloat1  > &E,
                              const __BrtArray<__BrtFloat1  > &pi,
                              const __BrtFloat1  &T,
                              __BrtFloat1  &output)
{
  __BrtFloat1  ex = E[index.swizzle1(maskX)];
  __BrtFloat1  ey = E[index.swizzle1(maskY)];
  __BrtFloat1  An = __BrtFloat1(32.000000f) * (__BrtFloat1(1.000000f) + __exp_cpu_inner((ex - ey) / T));
  __BrtFloat1  pi_plus = pi[index.swizzle1(maskX)] + pi[index.swizzle1(maskY)];

  output = pi_plus / An;
}
void  __gpuGDAMatrix_cpu(::brook::Kernel *__k, const std::vector<void *>&args)
{
  ::brook::StreamInterface *arg_index = (::brook::StreamInterface *) args[0];
  __BrtArray<__BrtFloat1  > *arg_E = (__BrtArray<__BrtFloat1  > *) args[1];
  __BrtArray<__BrtFloat1  > *arg_pi = (__BrtArray<__BrtFloat1  > *) args[2];
  __BrtFloat1 *arg_T = (__BrtFloat1 *) args[3];
  ::brook::StreamInterface *arg_output = (::brook::StreamInterface *) args[4];
  
  do {
    Addressable <__BrtFloat1  > __out_arg_output((__BrtFloat1 *) __k->FetchElem(arg_output));
    __gpuGDAMatrix_cpu_inner (Addressable <__BrtFloat2 >((__BrtFloat2 *) __k->FetchElem(arg_index)),
                              *arg_E,
                              *arg_pi,
                              *arg_T,
                              __out_arg_output);
    *reinterpret_cast<__BrtFloat1 *>(__out_arg_output.address) = __out_arg_output.castToArg(*reinterpret_cast<__BrtFloat1 *>(__out_arg_output.address));
  } while (__k->Continue());
}

void  gpuGDAMatrix (::brook::stream index,
		::brook::stream E,
		::brook::stream pi,
		const float  T,
		::brook::stream output) {
  static const void *__gpuGDAMatrix_fp[] = {
     "fp30", __gpuGDAMatrix_fp30,
     "fp40", __gpuGDAMatrix_fp40,
     "arb", __gpuGDAMatrix_arb,
     "ps20", __gpuGDAMatrix_ps20,
     "ps2b", __gpuGDAMatrix_ps2b,
     "ps2a", __gpuGDAMatrix_ps2a,
     "ps30", __gpuGDAMatrix_ps30,
     "cpu", (void *) __gpuGDAMatrix_cpu,
     NULL, NULL };
  static ::brook::kernel  __k(__gpuGDAMatrix_fp);

  __k->PushStream(index);
  __k->PushGatherStream(E);
  __k->PushGatherStream(pi);
  __k->PushConstant(T);
  __k->PushOutput(output);
  __k->Map();

}


static const char *__gpuGDAReduce_ps20= NULL;
static const char *__gpuGDAReduce_ps2b= NULL;
static const char *__gpuGDAReduce_ps2a= NULL;
static const char *__gpuGDAReduce_ps30= NULL;
static const char *__gpuGDAReduce_fp30= NULL;
static const char *__gpuGDAReduce_fp40= NULL;

namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __gpuGDAReduce_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.reduction_factor(2)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"# cgc version 1.4.0001, build date Mar  9 2006 20:56:09\n"
				"# command line args: -quiet -DCGC=1 -profile arbfp1 -DUSERECT=1 -profileopts MaxTexIndirections=4,NoDepenentReadLimit=0,NumInstructionSlots=96\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile arbfp1\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float4 __workspace : C0 : c[0] : 5 : 0\n"
				"PARAM c[1] = { program.local[0] };\n"
				"TEMP R0;\n"
				"TEMP R1;\n"
				"TEX R1.x, fragment.texcoord[0], texture[0], RECT;\n"
				"TEX R0.x, fragment.texcoord[1], texture[1], RECT;\n"
				"ADD result.color.x, R0, R1;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:2:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(3)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"# cgc version 1.4.0001, build date Mar  9 2006 20:56:09\n"
				"# command line args: -quiet -DCGC=1 -profile arbfp1 -DUSERECT=1 -profileopts MaxTexIndirections=4,NoDepenentReadLimit=0,NumInstructionSlots=96\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile arbfp1\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float4 __workspace : C0 : c[0] : 6 : 0\n"
				"PARAM c[1] = { program.local[0] };\n"
				"TEMP R0;\n"
				"TEMP R1;\n"
				"TEX R0.x, fragment.texcoord[1], texture[0], RECT;\n"
				"TEX R1.x, fragment.texcoord[0], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R1.x;\n"
				"TEX R0.x, fragment.texcoord[2], texture[1], RECT;\n"
				"ADD result.color.x, R0, R0.y;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:3:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(4)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"# cgc version 1.4.0001, build date Mar  9 2006 20:56:09\n"
				"# command line args: -quiet -DCGC=1 -profile arbfp1 -DUSERECT=1 -profileopts MaxTexIndirections=4,NoDepenentReadLimit=0,NumInstructionSlots=96\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile arbfp1\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float4 __workspace : C0 : c[0] : 7 : 0\n"
				"PARAM c[1] = { program.local[0] };\n"
				"TEMP R0;\n"
				"TEMP R1;\n"
				"TEX R0.x, fragment.texcoord[1], texture[0], RECT;\n"
				"TEX R1.x, fragment.texcoord[0], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R1.x;\n"
				"TEX R0.x, fragment.texcoord[2], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[3], texture[1], RECT;\n"
				"ADD result.color.x, R0, R0.y;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:4:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(5)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"# cgc version 1.4.0001, build date Mar  9 2006 20:56:09\n"
				"# command line args: -quiet -DCGC=1 -profile arbfp1 -DUSERECT=1 -profileopts MaxTexIndirections=4,NoDepenentReadLimit=0,NumInstructionSlots=96\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile arbfp1\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float4 __workspace : C0 : c[0] : 8 : 0\n"
				"PARAM c[1] = { program.local[0] };\n"
				"TEMP R0;\n"
				"TEMP R1;\n"
				"TEX R0.x, fragment.texcoord[1], texture[0], RECT;\n"
				"TEX R1.x, fragment.texcoord[0], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R1.x;\n"
				"TEX R0.x, fragment.texcoord[2], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[3], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[4], texture[1], RECT;\n"
				"ADD result.color.x, R0, R0.y;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:5:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(6)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"# cgc version 1.4.0001, build date Mar  9 2006 20:56:09\n"
				"# command line args: -quiet -DCGC=1 -profile arbfp1 -DUSERECT=1 -profileopts MaxTexIndirections=4,NoDepenentReadLimit=0,NumInstructionSlots=96\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile arbfp1\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"#var float4 __workspace : C0 : c[0] : 9 : 0\n"
				"PARAM c[1] = { program.local[0] };\n"
				"TEMP R0;\n"
				"TEMP R1;\n"
				"TEX R0.x, fragment.texcoord[1], texture[0], RECT;\n"
				"TEX R1.x, fragment.texcoord[0], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R1.x;\n"
				"TEX R0.x, fragment.texcoord[2], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[3], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[4], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[5], texture[1], RECT;\n"
				"ADD result.color.x, R0, R0.y;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:6:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(7)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"# cgc version 1.4.0001, build date Mar  9 2006 20:56:09\n"
				"# command line args: -quiet -DCGC=1 -profile arbfp1 -DUSERECT=1 -profileopts MaxTexIndirections=4,NoDepenentReadLimit=0,NumInstructionSlots=96\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile arbfp1\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex___reduce6_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD6 : TEX6 : 9 : 1\n"
				"#var float4 __workspace : C0 : c[0] : 10 : 0\n"
				"PARAM c[1] = { program.local[0] };\n"
				"TEMP R0;\n"
				"TEMP R1;\n"
				"TEX R0.x, fragment.texcoord[1], texture[0], RECT;\n"
				"TEX R1.x, fragment.texcoord[0], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R1.x;\n"
				"TEX R0.x, fragment.texcoord[2], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[3], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[4], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[5], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[6], texture[1], RECT;\n"
				"ADD result.color.x, R0, R0.y;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:7:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.output(0, 0)
			)
		)
		.technique( gpu_technique_desc()
			.reduction_factor(8)
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"# cgc version 1.4.0001, build date Mar  9 2006 20:56:09\n"
				"# command line args: -quiet -DCGC=1 -profile arbfp1 -DUSERECT=1 -profileopts MaxTexIndirections=4,NoDepenentReadLimit=0,NumInstructionSlots=96\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile arbfp1\n"
				"#program main\n"
				"#semantic main._tex_input : TEXUNIT0\n"
				"#semantic main._tex_output : TEXUNIT1\n"
				"#semantic main.__workspace : C0\n"
				"#var samplerRECT _tex_input : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float2 _tex_input_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var float __output_0 : $vout.COLOR0 : COL : 2 : 1\n"
				"#var samplerRECT _tex_output : TEXUNIT1 : texunit 1 : 3 : 1\n"
				"#var float2 _tex___reduce2_pos : $vin.TEXCOORD1 : TEX1 : 4 : 1\n"
				"#var float2 _tex___reduce3_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float2 _tex___reduce4_pos : $vin.TEXCOORD3 : TEX3 : 6 : 1\n"
				"#var float2 _tex___reduce5_pos : $vin.TEXCOORD4 : TEX4 : 7 : 1\n"
				"#var float2 _tex___reduce6_pos : $vin.TEXCOORD5 : TEX5 : 8 : 1\n"
				"#var float2 _tex___reduce7_pos : $vin.TEXCOORD6 : TEX6 : 9 : 1\n"
				"#var float2 _tex_output_pos : $vin.TEXCOORD7 : TEX7 : 10 : 1\n"
				"#var float4 __workspace : C0 : c[0] : 11 : 0\n"
				"PARAM c[1] = { program.local[0] };\n"
				"TEMP R0;\n"
				"TEMP R1;\n"
				"TEX R0.x, fragment.texcoord[1], texture[0], RECT;\n"
				"TEX R1.x, fragment.texcoord[0], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R1.x;\n"
				"TEX R0.x, fragment.texcoord[2], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[3], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[4], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[5], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[6], texture[0], RECT;\n"
				"ADD R0.y, R0.x, R0;\n"
				"TEX R0.x, fragment.texcoord[7], texture[1], RECT;\n"
				"ADD result.color.x, R0, R0.y;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:2\n"
				"##s:1:input\n"
				"##s:1:output\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:8:\n"
				"")
				.sampler(0, 0)
				.sampler(0, 1)
				.interpolant(0, 0)
				.interpolant(0, 1)
				.interpolant(0, 2)
				.interpolant(0, 3)
				.interpolant(0, 4)
				.interpolant(0, 5)
				.interpolant(0, 6)
				.interpolant(0, 7)
				.output(0, 0)
			)
		);
	static const void* __gpuGDAReduce_arb = &__gpuGDAReduce_arb_desc;
}

void  __gpuGDAReduce_cpu_inner(const __BrtFloat1  &input,
                              __BrtFloat1  &output)
{
  output = output + input;
}
void  __gpuGDAReduce_cpu(::brook::Kernel *__k, const std::vector<void *>&args)
{
  ::brook::StreamInterface *arg_input = (::brook::StreamInterface *) args[0];
  ::brook::StreamInterface *arg_output = (::brook::StreamInterface *) args[1];
  
  do {
    Addressable <__BrtFloat1  > __out_arg_output((__BrtFloat1 *) __k->FetchElem(arg_output));
    __gpuGDAReduce_cpu_inner (Addressable <__BrtFloat1 >((__BrtFloat1 *) __k->FetchElem(arg_input)),
                              __out_arg_output);
    *reinterpret_cast<__BrtFloat1 *>(__out_arg_output.address) = __out_arg_output.castToArg(*reinterpret_cast<__BrtFloat1 *>(__out_arg_output.address));
  } while (__k->Continue());
}

void  gpuGDAReduce (::brook::stream input,
		::brook::stream output) {
  static const void *__gpuGDAReduce_fp[] = {
     "fp30", __gpuGDAReduce_fp30,
     "fp40", __gpuGDAReduce_fp40,
     "arb", __gpuGDAReduce_arb,
     "ps20", __gpuGDAReduce_ps20,
     "ps2b", __gpuGDAReduce_ps2b,
     "ps2a", __gpuGDAReduce_ps2a,
     "ps30", __gpuGDAReduce_ps30,
     "cpu", (void *) __gpuGDAReduce_cpu,
     NULL, NULL };
  static ::brook::kernel  __k(__gpuGDAReduce_fp);

  __k->PushStream(input);
  __k->PushReduce(&output, __BRTReductionType(&output));
  __k->Reduce();

}

void  gpuGDAReduce (::brook::stream input,
		float  & output) {
  static const void *__gpuGDAReduce_fp[] = {
     "fp30", __gpuGDAReduce_fp30,
     "fp40", __gpuGDAReduce_fp40,
     "arb", __gpuGDAReduce_arb,
     "ps20", __gpuGDAReduce_ps20,
     "ps2b", __gpuGDAReduce_ps2b,
     "ps2a", __gpuGDAReduce_ps2a,
     "ps30", __gpuGDAReduce_ps30,
     "cpu", (void *) __gpuGDAReduce_cpu,
     NULL, NULL };
  static ::brook::kernel  __k(__gpuGDAReduce_fp);

  __k->PushStream(input);
  __k->PushReduce(&output, __BRTReductionType(&output));
  __k->Reduce();

}


static const char *__gpuBlendKernel_ps20= NULL;
static const char *__gpuBlendKernel_ps2b= NULL;
static const char *__gpuBlendKernel_ps2a= NULL;
static const char *__gpuBlendKernel_ps30= NULL;
static const char *__gpuBlendKernel_fp30= NULL;
static const char *__gpuBlendKernel_fp40= NULL;

namespace {
	using namespace ::brook::desc;
	static const gpu_kernel_desc __gpuBlendKernel_arb_desc = gpu_kernel_desc()
		.technique( gpu_technique_desc()
			.pass( gpu_pass_desc(
				"!!ARBfp1.0\n"
				"# cgc version 1.4.0001, build date Mar  9 2006 20:56:09\n"
				"# command line args: -quiet -DCGC=1 -profile arbfp1 -DUSERECT=1 -profileopts MaxTexIndirections=4,NoDepenentReadLimit=0,NumInstructionSlots=96\n"
				"#vendor NVIDIA Corporation\n"
				"#version 1.0.02\n"
				"#profile arbfp1\n"
				"#program main\n"
				"#semantic main._tex_black : TEXUNIT0\n"
				"#semantic main._tex_white : TEXUNIT1\n"
				"#semantic main._tex_mask : TEXUNIT2\n"
				"#semantic main.scale : C0\n"
				"#semantic main.clamp_min : C1\n"
				"#semantic main.clamp_max : C2\n"
				"#semantic main.__workspace : C3\n"
				"#var samplerRECT _tex_black : TEXUNIT0 : texunit 0 : 0 : 1\n"
				"#var float2 _tex_black_pos : $vin.TEXCOORD0 : TEX0 : 1 : 1\n"
				"#var samplerRECT _tex_white : TEXUNIT1 : texunit 1 : 2 : 1\n"
				"#var float2 _tex_white_pos : $vin.TEXCOORD1 : TEX1 : 3 : 1\n"
				"#var samplerRECT _tex_mask : TEXUNIT2 : texunit 2 : 4 : 1\n"
				"#var float2 _tex_mask_pos : $vin.TEXCOORD2 : TEX2 : 5 : 1\n"
				"#var float scale : C0 : c[0] : 6 : 1\n"
				"#var float clamp_min : C1 : c[1] : 7 : 1\n"
				"#var float clamp_max : C2 : c[2] : 8 : 1\n"
				"#var float3 __output_0 : $vout.COLOR0 : COL : 9 : 1\n"
				"#var float4 __workspace : C3 : c[3] : 10 : 0\n"
				"#const c[4] = 1\n"
				"PARAM c[5] = { program.local[0..3],\n"
				"		{ 1 } };\n"
				"TEMP R0;\n"
				"TEMP R1;\n"
				"RCP R0.y, c[0].x;\n"
				"TEX R0.x, fragment.texcoord[2], texture[2], RECT;\n"
				"MUL R0.w, R0.x, R0.y;\n"
				"TEX R0.xyz, fragment.texcoord[0], texture[0], RECT;\n"
				"ADD R1.x, -R0.w, c[4];\n"
				"MUL R1.xyz, R1.x, R0;\n"
				"TEX R0.xyz, fragment.texcoord[1], texture[1], RECT;\n"
				"MAD R0.xyz, R0.w, R0, R1;\n"
				"MAX R0.xyz, R0, c[1].x;\n"
				"MIN result.color.xyz, R0, c[2].x;\n"
				"END \n"
				"##!!BRCC\n"
				"##narg:7\n"
				"##s:3:black\n"
				"##s:3:white\n"
				"##s:1:mask\n"
				"##c:1:scale\n"
				"##c:1:clamp_min\n"
				"##c:1:clamp_max\n"
				"##o:3:o\n"
				"##workspace:1024\n"
				"##!!multipleOutputInfo:0:1:\n"
				"##!!fullAddressTrans:0:\n"
				"##!!reductionFactor:0:\n"
				"")
				.constant(4, 0)
				.constant(5, 0)
				.constant(6, 0)
				.sampler(1, 0)
				.sampler(2, 0)
				.sampler(3, 0)
				.interpolant(1, kStreamInterpolant_Position)
				.interpolant(2, kStreamInterpolant_Position)
				.interpolant(3, kStreamInterpolant_Position)
				.output(7, 0)
			)
		);
	static const void* __gpuBlendKernel_arb = &__gpuBlendKernel_arb_desc;
}

void  __gpuBlendKernel_cpu_inner(const __BrtFloat3  &black,
                                const __BrtFloat3  &white,
                                const __BrtFloat1  &mask,
                                const __BrtFloat1  &scale,
                                const __BrtFloat1  &clamp_min,
                                const __BrtFloat1  &clamp_max,
                                __BrtFloat3  &o)
{
  __BrtFloat1  whiteCoeff = mask / scale;
  __BrtFloat1  blackCoeff = __BrtFloat1(1.000000f) - whiteCoeff;

  o = __min_cpu_inner(__max_cpu_inner(whiteCoeff * white + blackCoeff * black,clamp_min),clamp_max);
}
void  __gpuBlendKernel_cpu(::brook::Kernel *__k, const std::vector<void *>&args)
{
  ::brook::StreamInterface *arg_black = (::brook::StreamInterface *) args[0];
  ::brook::StreamInterface *arg_white = (::brook::StreamInterface *) args[1];
  ::brook::StreamInterface *arg_mask = (::brook::StreamInterface *) args[2];
  __BrtFloat1 *arg_scale = (__BrtFloat1 *) args[3];
  __BrtFloat1 *arg_clamp_min = (__BrtFloat1 *) args[4];
  __BrtFloat1 *arg_clamp_max = (__BrtFloat1 *) args[5];
  ::brook::StreamInterface *arg_o = (::brook::StreamInterface *) args[6];
  
  do {
    Addressable <__BrtFloat3  > __out_arg_o((__BrtFloat3 *) __k->FetchElem(arg_o));
    __gpuBlendKernel_cpu_inner (Addressable <__BrtFloat3 >((__BrtFloat3 *) __k->FetchElem(arg_black)),
                                Addressable <__BrtFloat3 >((__BrtFloat3 *) __k->FetchElem(arg_white)),
                                Addressable <__BrtFloat1 >((__BrtFloat1 *) __k->FetchElem(arg_mask)),
                                *arg_scale,
                                *arg_clamp_min,
                                *arg_clamp_max,
                                __out_arg_o);
    *reinterpret_cast<__BrtFloat3 *>(__out_arg_o.address) = __out_arg_o.castToArg(*reinterpret_cast<__BrtFloat3 *>(__out_arg_o.address));
  } while (__k->Continue());
}

void  gpuBlendKernel (::brook::stream black,
		::brook::stream white,
		::brook::stream mask,
		const float  scale,
		const float  clamp_min,
		const float  clamp_max,
		::brook::stream o) {
  static const void *__gpuBlendKernel_fp[] = {
     "fp30", __gpuBlendKernel_fp30,
     "fp40", __gpuBlendKernel_fp40,
     "arb", __gpuBlendKernel_arb,
     "ps20", __gpuBlendKernel_ps20,
     "ps2b", __gpuBlendKernel_ps2b,
     "ps2a", __gpuBlendKernel_ps2a,
     "ps30", __gpuBlendKernel_ps30,
     "cpu", (void *) __gpuBlendKernel_cpu,
     NULL, NULL };
  static ::brook::kernel  __k(__gpuBlendKernel_fp);

  __k->PushStream(black);
  __k->PushStream(white);
  __k->PushStream(mask);
  __k->PushConstant(scale);
  __k->PushConstant(clamp_min);
  __k->PushConstant(clamp_max);
  __k->PushOutput(o);
  __k->Map();

}



